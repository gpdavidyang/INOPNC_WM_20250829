# üîß Ïù∏Ï¶ù ÏãúÏä§ÌÖú Î¶¨Ìå©ÌÜ†ÎßÅ Í≥ÑÌöçÏÑú

## üìã Í∞úÏöî

ÌòÑÏû¨ Next.js Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùò Ïù∏Ï¶ù ÏãúÏä§ÌÖúÏóêÏÑú Î∞úÍ≤¨Îêú Ï≤¥Í≥ÑÏ†ÅÏù∏ Íµ¨Ï°∞Ï†Å Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌïú Îã®Í≥ÑÎ≥Ñ Î¶¨Ìå©ÌÜ†ÎßÅ Í≥ÑÌöçÏûÖÎãàÎã§.

### ÌòÑÏû¨ ÏÉÅÌô©

- ‚ùå Î°úÏª¨ ÌôòÍ≤Ω: Î°úÍ∑∏Ïù∏ ÌõÑ Î¨¥Ìïú Î¶¨Îã§Ïù¥Î†âÌä∏ Î£®ÌîÑ
- ‚ùå Î∞∞Ìè¨ ÌôòÍ≤Ω: Î°úÍ∑∏Ïù∏ ÌôîÎ©¥ Î°úÎî© Ïã§Ìå®
- ‚ùå ÏΩîÎìú Íµ¨Ï°∞: SOLID ÏõêÏπô ÏúÑÎ∞ò, Ï§ëÎ≥µÎêú Î°úÏßÅ, Î∂àÎ™ÖÌôïÌïú Í≤ΩÍ≥Ñ

### Î™©Ìëú

- ‚úÖ ÏïàÏ†ïÏ†ÅÏù∏ Ïù∏Ï¶ù ÌîåÎ°úÏö∞ Íµ¨Ï∂ï
- ‚úÖ Î™ÖÌôïÌïú ÏïÑÌÇ§ÌÖçÏ≤ò Í≤ΩÍ≥Ñ ÏÑ§Ï†ï
- ‚úÖ ÏÑ±Îä• ÏµúÏ†ÅÌôî Î∞è Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ìñ•ÏÉÅ

---

## üöÄ Phase 0: Í∏¥Í∏â ÏïàÏ†ïÌôî (1-2Ïùº)

### Î™©Ìëú

Ï¶âÏãú ÌîÑÎ°úÎçïÏÖò Ïù¥ÏäàÎ•º Ìï¥Í≤∞ÌïòÍ≥† ÏãúÏä§ÌÖúÏùÑ ÏïàÏ†ïÌôî

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### 1. Circuit Breaker Pattern for Redirect Loop Prevention

```typescript
// lib/auth/circuit-breaker.ts
export class AuthCircuitBreaker {
  private static readonly MAX_REDIRECTS = 3
  private static readonly RESET_TIME = 5000 // 5 seconds

  static checkRedirect(path: string): boolean {
    if (typeof window === 'undefined') return true

    const key = 'auth_redirects'
    const now = Date.now()
    const redirects = JSON.parse(sessionStorage.getItem(key) || '[]')

    // Clean old redirects
    const recent = redirects.filter((r: any) => now - r.time < this.RESET_TIME)

    if (recent.length >= this.MAX_REDIRECTS) {
      console.error('Redirect loop detected!')
      sessionStorage.removeItem(key)
      return false // Break the circuit
    }

    recent.push({ path, time: now })
    sessionStorage.setItem(key, JSON.stringify(recent))
    return true
  }

  static reset(): void {
    if (typeof window !== 'undefined') {
      sessionStorage.removeItem('auth_redirects')
    }
  }
}
```

#### 2. Centralized Role Routing

```typescript
// lib/auth/routing.ts
export const AUTH_ROUTES = {
  LOGIN: '/auth/login',
  DASHBOARD: {
    ADMIN: '/dashboard/admin',
    PARTNER: '/partner/dashboard',
    MOBILE: '/mobile',
  },
} as const

export function getRoleBasedRoute(role: string | null): string {
  const roleRouteMap: Record<string, string> = {
    system_admin: AUTH_ROUTES.DASHBOARD.ADMIN,
    admin: AUTH_ROUTES.DASHBOARD.ADMIN,
    customer_manager: AUTH_ROUTES.DASHBOARD.PARTNER,
    partner: AUTH_ROUTES.DASHBOARD.PARTNER,
    worker: AUTH_ROUTES.DASHBOARD.MOBILE,
    site_manager: AUTH_ROUTES.DASHBOARD.MOBILE,
  }

  return roleRouteMap[role || ''] || AUTH_ROUTES.DASHBOARD.ADMIN
}

export function shouldAccessMobile(role: string): boolean {
  return ['worker', 'site_manager', 'customer_manager'].includes(role)
}
```

#### 3. Environment Configuration Safety

```typescript
// lib/config/env.ts
export class EnvConfig {
  static get supabaseUrl(): string {
    const url = process.env.NEXT_PUBLIC_SUPABASE_URL
    if (!url && process.env.NODE_ENV === 'production') {
      throw new Error('NEXT_PUBLIC_SUPABASE_URL is required in production')
    }
    return url || 'http://localhost:54321'
  }

  static get supabaseAnonKey(): string {
    const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    if (!key && process.env.NODE_ENV === 'production') {
      throw new Error('NEXT_PUBLIC_SUPABASE_ANON_KEY is required in production')
    }
    return key || 'dummy-key-for-development'
  }

  static validate(): void {
    this.supabaseUrl
    this.supabaseAnonKey
  }
}
```

### ÌÖåÏä§Ìä∏ Í≥ÑÌöç

- Unit tests for circuit breaker
- Integration tests for role routing
- E2E tests for login flow

### ÏÑ±Í≥µ ÏßÄÌëú

- Î¨¥Ìïú Î£®ÌîÑ 0Í±¥
- Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µÎ•† > 95%

---

## üèóÔ∏è Phase 1: Ïù∏Ï¶ù ÏÑúÎπÑÏä§ Î†àÏù¥Ïñ¥ Íµ¨Ï∂ï (3-4Ïùº)

### Î™©Ìëú

Ï§ëÏïô ÏßëÏ§ëÏãù Ïù∏Ï¶ù ÏÑúÎπÑÏä§ Î†àÏù¥Ïñ¥ Íµ¨Ï∂ï

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### 1. Session Manager

```typescript
// lib/auth/services/session-manager.ts
import { Session, User } from '@supabase/supabase-js'

export interface ISessionManager {
  getSession(): Promise<Session | null>
  refreshSession(): Promise<Session | null>
  clearSession(): Promise<void>
  validateSession(session: Session): boolean
}

export class SessionManager implements ISessionManager {
  private static instance: SessionManager
  private sessionCache: Session | null = null
  private cacheExpiry: number = 0
  private readonly CACHE_DURATION = 5 * 60 * 1000 // 5 minutes

  static getInstance(): SessionManager {
    if (!SessionManager.instance) {
      SessionManager.instance = new SessionManager()
    }
    return SessionManager.instance
  }

  async getSession(): Promise<Session | null> {
    // Check cache first
    if (this.sessionCache && Date.now() < this.cacheExpiry) {
      return this.sessionCache
    }

    // Fetch fresh session
    const {
      data: { session },
    } = await supabase.auth.getSession()

    if (session && this.validateSession(session)) {
      this.sessionCache = session
      this.cacheExpiry = Date.now() + this.CACHE_DURATION
      return session
    }

    return null
  }

  async refreshSession(): Promise<Session | null> {
    const {
      data: { session },
      error,
    } = await supabase.auth.refreshSession()

    if (error || !session) {
      await this.clearSession()
      return null
    }

    this.sessionCache = session
    this.cacheExpiry = Date.now() + this.CACHE_DURATION
    return session
  }

  async clearSession(): Promise<void> {
    this.sessionCache = null
    this.cacheExpiry = 0
    await supabase.auth.signOut()
  }

  validateSession(session: Session): boolean {
    if (!session || !session.access_token || !session.user) {
      return false
    }

    // Check token expiry
    const tokenExp = session.expires_at || 0
    const now = Math.floor(Date.now() / 1000)

    return tokenExp > now
  }
}
```

#### 2. Permission Service

```typescript
// lib/auth/services/permission-service.ts
export interface IPermissionService {
  canAccessRoute(role: string, route: string): boolean
  canPerformAction(role: string, action: string): boolean
  getRolePermissions(role: string): string[]
}

export class PermissionService implements IPermissionService {
  private readonly permissions: Record<string, string[]> = {
    system_admin: ['*'], // All permissions
    admin: ['dashboard.*', 'reports.*', 'users.*'],
    site_manager: ['mobile.*', 'workers.*', 'daily-reports.*'],
    worker: ['mobile.worklog', 'mobile.documents'],
    customer_manager: ['partner.*', 'documents.*'],
  }

  canAccessRoute(role: string, route: string): boolean {
    const rolePerms = this.permissions[role] || []

    // Check for wildcard permission
    if (rolePerms.includes('*')) return true

    // Check specific route permission
    return rolePerms.some(perm => {
      if (perm.endsWith('*')) {
        const prefix = perm.slice(0, -1)
        return route.startsWith(prefix)
      }
      return perm === route
    })
  }

  canPerformAction(role: string, action: string): boolean {
    return this.canAccessRoute(role, action)
  }

  getRolePermissions(role: string): string[] {
    return this.permissions[role] || []
  }
}
```

### ÌÖåÏä§Ìä∏ Í≥ÑÌöç

- Mock Supabase client for testing
- Unit tests for all service methods
- Integration tests with real auth flow

### ÏÑ±Í≥µ ÏßÄÌëú

- ÏÑ∏ÏÖò Ï∫êÏãú ÌûàÌä∏Ïú® > 80%
- Í∂åÌïú Ï≤¥ÌÅ¨ ÏÑ±Îä• < 10ms

---

## üîå Phase 2: Ïù∏Ï¶ù ÌîÑÎ°úÎ∞îÏù¥Îçî Ï∂îÏÉÅÌôî (2-3Ïùº)

### Î™©Ìëú

Supabase ÏùòÏ°¥ÏÑ±ÏùÑ Ï∂îÏÉÅÌôîÌïòÏó¨ ÌÖåÏä§Ìä∏ Í∞ÄÎä•ÏÑ±Í≥º Ïú†Ïó∞ÏÑ± Ìñ•ÏÉÅ

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### Auth Provider Interface

```typescript
// lib/auth/providers/auth-provider.interface.ts
export interface IAuthProvider {
  signIn(email: string, password: string): Promise<AuthResult>
  signOut(): Promise<void>
  getSession(): Promise<Session | null>
  refreshSession(): Promise<Session | null>
  onAuthStateChange(callback: (session: Session | null) => void): () => void
}

export interface AuthResult {
  success: boolean
  session?: Session
  error?: string
}
```

#### Supabase Provider Implementation

```typescript
// lib/auth/providers/supabase-provider.ts
export class SupabaseAuthProvider implements IAuthProvider {
  private client: SupabaseClient

  constructor(client: SupabaseClient) {
    this.client = client
  }

  async signIn(email: string, password: string): Promise<AuthResult> {
    const { data, error } = await this.client.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      return { success: false, error: error.message }
    }

    return { success: true, session: data.session }
  }

  async signOut(): Promise<void> {
    await this.client.auth.signOut()
  }

  async getSession(): Promise<Session | null> {
    const {
      data: { session },
    } = await this.client.auth.getSession()
    return session
  }

  async refreshSession(): Promise<Session | null> {
    const {
      data: { session },
    } = await this.client.auth.refreshSession()
    return session
  }

  onAuthStateChange(callback: (session: Session | null) => void): () => void {
    const {
      data: { subscription },
    } = this.client.auth.onAuthStateChange((_event, session) => callback(session))

    return () => subscription.unsubscribe()
  }
}
```

### ÌÖåÏä§Ìä∏ Í≥ÑÌöç

- Mock provider for testing
- Provider switching tests
- Error handling tests

### ÏÑ±Í≥µ ÏßÄÌëú

- 100% provider interface coverage
- Zero Supabase dependencies in business logic

---

## ‚öõÔ∏è Phase 3: React Context & Hooks (2-3Ïùº)

### Î™©Ìëú

React Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏúÑÌïú ÍπîÎÅîÌïú Ïù∏Ï¶ù Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ï†úÍ≥µ

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### Auth Context Provider

```typescript
// lib/auth/context/auth-context.tsx
'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';

interface AuthContextValue {
  user: User | null;
  session: Session | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
  refreshSession: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const sessionManager = SessionManager.getInstance();
  const authProvider = new SupabaseAuthProvider(supabase);

  useEffect(() => {
    // Initial session load
    loadSession();

    // Subscribe to auth changes
    const unsubscribe = authProvider.onAuthStateChange((newSession) => {
      setSession(newSession);
      setUser(newSession?.user || null);
    });

    return unsubscribe;
  }, []);

  const loadSession = async () => {
    setIsLoading(true);
    try {
      const session = await sessionManager.getSession();
      setSession(session);
      setUser(session?.user || null);
    } finally {
      setIsLoading(false);
    }
  };

  const signIn = async (email: string, password: string) => {
    const result = await authProvider.signIn(email, password);
    if (!result.success) {
      throw new Error(result.error);
    }
    await loadSession();
  };

  const signOut = async () => {
    await authProvider.signOut();
    setSession(null);
    setUser(null);
    AuthCircuitBreaker.reset();
  };

  const refreshSession = async () => {
    await sessionManager.refreshSession();
    await loadSession();
  };

  const value: AuthContextValue = {
    user,
    session,
    isLoading,
    isAuthenticated: !!session,
    signIn,
    signOut,
    refreshSession,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
```

#### useAuth Hook

```typescript
// lib/auth/hooks/use-auth.ts
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

export function useRequireAuth(redirectTo = '/auth/login') {
  const { isAuthenticated, isLoading } = useAuth()
  const router = useRouter()

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push(redirectTo)
    }
  }, [isAuthenticated, isLoading, redirectTo, router])

  return { isAuthenticated, isLoading }
}
```

#### Protected Route Component

```typescript
// lib/auth/components/protected-route.tsx
export function ProtectedRoute({
  children,
  roles,
  fallback = null
}: {
  children: React.ReactNode;
  roles?: string[];
  fallback?: React.ReactNode;
}) {
  const { user, isLoading } = useAuth();
  const permissionService = new PermissionService();

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!user) {
    return null; // useRequireAuth will handle redirect
  }

  if (roles && !roles.includes(user.role)) {
    return fallback || <UnauthorizedError />;
  }

  return <>{children}</>;
}
```

### ÌÖåÏä§Ìä∏ Í≥ÑÌöç

- React Testing Library tests
- Hook testing with renderHook
- Context provider tests

### ÏÑ±Í≥µ ÏßÄÌëú

- Zero prop drilling for auth state
- < 50ms auth state updates

---

## üîÑ Phase 4: ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î∞è ÌÖåÏä§ÌåÖ (3-4Ïùº)

### Î™©Ìëú

Í∏∞Ï°¥ Ïª¥Ìè¨ÎÑåÌä∏Î•º ÏÉàÎ°úÏö¥ ÏïÑÌÇ§ÌÖçÏ≤òÎ°ú ÏïàÏ†ÑÌïòÍ≤å ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### Migration Guide

```typescript
// BEFORE - Old pattern
export default async function DashboardPage() {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect('/auth/login');
  }

  if (user.role === 'admin') {
    redirect('/dashboard/admin');
  }
  // ... rest of logic
}

// AFTER - New pattern
export default function DashboardPage() {
  const { user } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (user) {
      const route = getRoleBasedRoute(user.role);
      router.push(route);
    }
  }, [user, router]);

  return (
    <ProtectedRoute>
      <DashboardContent />
    </ProtectedRoute>
  );
}
```

#### Testing Strategy

```typescript
// tests/auth/integration.test.ts
describe('Authentication Flow', () => {
  it('should handle login ‚Üí dashboard ‚Üí mobile redirect', async () => {
    const { result } = renderHook(() => useAuth(), {
      wrapper: AuthProvider,
    })

    // Login as site_manager
    await act(async () => {
      await result.current.signIn('manager@test.com', 'password')
    })

    expect(result.current.user?.role).toBe('site_manager')
    expect(mockRouter.push).toHaveBeenCalledWith('/mobile')
  })

  it('should prevent infinite redirect loops', async () => {
    let redirectCount = 0
    mockRouter.push.mockImplementation(() => {
      redirectCount++
      if (redirectCount > 5) {
        throw new Error('Too many redirects')
      }
    })

    // Should not throw
    renderHook(() => useRequireAuth(), {
      wrapper: AuthProvider,
    })

    expect(redirectCount).toBeLessThanOrEqual(3)
  })
})
```

### ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

- [ ] `/app/auth/actions.ts` - ÏÉàÎ°úÏö¥ AuthProvider ÏÇ¨Ïö©
- [ ] `/middleware.ts` - Circuit breaker Ï∂îÍ∞Ä
- [ ] `/app/dashboard/page.tsx` - Ï§ëÏïô ÎùºÏö∞ÌåÖ ÏÇ¨Ïö©
- [ ] `/app/mobile/*` - ProtectedRoute Ï†ÅÏö©
- [ ] `/app/dashboard/admin/*` - useAuth hook Ï†ÅÏö©

### ÌÖåÏä§Ìä∏ Í≥ÑÌöç

- Unit tests: 100% coverage
- Integration tests: Ï£ºÏöî ÌîåÎ°úÏö∞
- E2E tests: Cypress/Playwright
- Load tests: ÎèôÏãú ÏÇ¨Ïö©Ïûê 100Î™Ö

### ÏÑ±Í≥µ ÏßÄÌëú

- Î™®Îì† ÌÖåÏä§Ìä∏ ÌÜµÍ≥º
- 0 regression bugs
- ÏÑ±Îä• Ï†ÄÌïò ÏóÜÏùå

---

## üìä Phase 5: Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏµúÏ†ÅÌôî (2-3Ïùº)

### Î™©Ìëú

ÌîÑÎ°úÎçïÏÖò Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏÑ±Îä• ÏµúÏ†ÅÌôî

### Íµ¨ÌòÑ ÎÇ¥Ïö©

#### Performance Monitoring

```typescript
// lib/auth/monitoring/auth-metrics.ts
export class AuthMetrics {
  private static metrics = {
    loginAttempts: 0,
    loginSuccess: 0,
    loginFailure: 0,
    sessionRefresh: 0,
    redirectLoops: 0,
  }

  static recordLoginAttempt(success: boolean) {
    this.metrics.loginAttempts++
    if (success) {
      this.metrics.loginSuccess++
    } else {
      this.metrics.loginFailure++
    }

    // Send to analytics
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'login_attempt', {
        success,
        success_rate: this.getSuccessRate(),
      })
    }
  }

  static recordRedirectLoop() {
    this.metrics.redirectLoops++
    console.error('Redirect loop detected!', {
      count: this.metrics.redirectLoops,
      timestamp: new Date().toISOString(),
    })

    // Alert if too many loops
    if (this.metrics.redirectLoops > 10) {
      // Send alert to monitoring service
    }
  }

  static getSuccessRate(): number {
    if (this.metrics.loginAttempts === 0) return 0
    return (this.metrics.loginSuccess / this.metrics.loginAttempts) * 100
  }
}
```

#### Error Boundary

```typescript
// lib/auth/components/auth-error-boundary.tsx
export class AuthErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Auth Error:', error, errorInfo);

    // Log to monitoring service
    if (error.message.includes('auth') || error.message.includes('session')) {
      AuthMetrics.recordAuthError(error);
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="auth-error">
          <h2>Ïù∏Ï¶ù Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§</h2>
          <button onClick={() => window.location.href = '/auth/login'}>
            Îã§Ïãú Î°úÍ∑∏Ïù∏
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥Îìú

- Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µÎ•†
- ÌèâÍ∑† ÏÑ∏ÏÖò ÏßÄÏÜç ÏãúÍ∞Ñ
- Î¶¨Îã§Ïù¥Î†âÌä∏ Î£®ÌîÑ Î∞úÏÉù ÎπàÎèÑ
- API ÏùëÎãµ ÏãúÍ∞Ñ
- ÏóêÎü¨Ïú®

### ÏÑ±Îä• ÏµúÏ†ÅÌôî

- Session caching: 80% Ï∫êÏãú ÌûàÌä∏Ïú®
- Lazy loading: Ïù∏Ï¶ù Í¥ÄÎ†® Ïª¥Ìè¨ÎÑåÌä∏
- Bundle optimization: ~20KB Í∞êÏÜå

---

## üéØ Íµ¨ÌòÑ Ïö∞ÏÑ†ÏàúÏúÑ Î∞è ÏùºÏ†ï

### Ï†ÑÏ≤¥ ÏùºÏ†ï: 13-19Ïùº

| Phase   | Í∏∞Í∞Ñ  | Ïö∞ÏÑ†ÏàúÏúÑ    | Î¶¨Ïä§ÌÅ¨ |
| ------- | ----- | ----------- | ------ |
| Phase 0 | 1-2Ïùº | üî¥ Critical | Low    |
| Phase 1 | 3-4Ïùº | üü† High     | Medium |
| Phase 2 | 2-3Ïùº | üü° Medium   | Low    |
| Phase 3 | 2-3Ïùº | üü° Medium   | Medium |
| Phase 4 | 3-4Ïùº | üü† High     | High   |
| Phase 5 | 2-3Ïùº | üü¢ Low      | Low    |

### Ï¶âÏãú Ïã§Ìñâ (Phase 0)

```bash
# 1. Circuit breaker Íµ¨ÌòÑ
npm run dev # ÌÖåÏä§Ìä∏
npm run test:auth # Ïù∏Ï¶ù ÌÖåÏä§Ìä∏

# 2. Î∞∞Ìè¨
git checkout -b fix/auth-infinite-loop
git add .
git commit -m "fix: prevent auth infinite redirect loops"
git push origin fix/auth-infinite-loop
```

---

## ‚úÖ ÏÑ±Í≥µ ÏßÄÌëú

### Í∏∞Ïà†Ï†Å ÏßÄÌëú

- **Î¨¥Ìïú Î£®ÌîÑ**: 0Í±¥
- **Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µÎ•†**: > 95%
- **ÏÑ∏ÏÖò Ï≤¥ÌÅ¨ ÏÑ±Îä•**: < 50ms
- **Ï∫êÏãú ÌûàÌä∏Ïú®**: > 80%
- **Î≤àÎì§ ÏÇ¨Ïù¥Ï¶à**: 20KB Í∞êÏÜå

### ÎπÑÏ¶àÎãàÏä§ ÏßÄÌëú

- **ÏßÄÏõê Ìã∞Ïºì**: 50% Í∞êÏÜå
- **ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ**: 20% Ìñ•ÏÉÅ
- **Í∞úÎ∞ú ÏÜçÎèÑ**: 30% Ìñ•ÏÉÅ
- **Î≤ÑÍ∑∏ Î∞úÏÉùÎ•†**: 70% Í∞êÏÜå

---

## üö® Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨

### Î¶¨Ïä§ÌÅ¨ Îß§Ìä∏Î¶≠Ïä§

| Î¶¨Ïä§ÌÅ¨                      | Í∞ÄÎä•ÏÑ± | ÏòÅÌñ•ÎèÑ   | ÎåÄÏùë Ï†ÑÎûµ                         |
| --------------------------- | ------ | -------- | --------------------------------- |
| ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï§ë ÏÑúÎπÑÏä§ Ï§ëÎã® | Low    | High     | Feature flag ÏÇ¨Ïö©, Ï†êÏßÑÏ†Å Î°§ÏïÑÏõÉ  |
| ÏÑ±Îä• Ï†ÄÌïò                   | Medium | Medium   | Ï∫êÏã± Ï†ÑÎûµ, ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ          |
| ÌïòÏúÑ Ìò∏ÌôòÏÑ± Î¨∏Ï†ú            | Medium | High     | Adapter Ìå®ÌÑ¥, Îã®Í≥ÑÏ†Å ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò |
| Î≥¥Ïïà Ï∑®ÏïΩÏ†ê                 | Low    | Critical | Î≥¥Ïïà Í∞êÏÇ¨, ÌéúÌÖåÏä§ÌåÖ               |

### Î°§Î∞± Í≥ÑÌöç

```bash
# PhaseÎ≥Ñ Î°§Î∞± ÌÉúÍ∑∏ ÏÉùÏÑ±
git tag -a v1.0-pre-refactor -m "Before auth refactoring"

# Î¨∏Ï†ú Î∞úÏÉù Ïãú Î°§Î∞±
git checkout v1.0-pre-refactor
npm run deploy:emergency
```

---

## üìö Ï∞∏Í≥† ÏûêÎ£å

### ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®ÌÑ¥

- [SOLID Principles in React](https://blog.logrocket.com/solid-principles-react/)
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

### Next.js ÌäπÌôî

- [Next.js Authentication Best Practices](https://nextjs.org/docs/authentication)
- [App Router Migration](https://nextjs.org/docs/app/building-your-application/routing)

### ÌÖåÏä§ÌåÖ

- [Testing React Applications](https://kentcdodds.com/blog/testing-react-apps)
- [E2E Testing with Playwright](https://playwright.dev/docs/intro)

---

## ü§ù ÌåÄ Ïó≠Ìï† Î∂ÑÎã¥

| Ïó≠Ìï†         | Îã¥ÎãπÏûê | Ï±ÖÏûÑ                     |
| ------------ | ------ | ------------------------ |
| Tech Lead    | TBD    | ÏïÑÌÇ§ÌÖçÏ≤ò Í≤∞Ï†ï, ÏΩîÎìú Î¶¨Î∑∞ |
| Frontend Dev | TBD    | React Ïª¥Ìè¨ÎÑåÌä∏, Hooks    |
| Backend Dev  | TBD    | ÏÑúÎπÑÏä§ Î†àÏù¥Ïñ¥, API       |
| QA Engineer  | TBD    | ÌÖåÏä§Ìä∏ Ï†ÑÎûµ, E2E ÌÖåÏä§Ìä∏  |
| DevOps       | TBD    | Î∞∞Ìè¨, Î™®ÎãàÌÑ∞ÎßÅ           |

---

## üìù Í≤∞Î°†

Ïù¥ Î¶¨Ìå©ÌÜ†ÎßÅ Í≥ÑÌöçÏùÄ ÌòÑÏû¨ Ïù∏Ï¶ù ÏãúÏä§ÌÖúÏùò Ï≤¥Í≥ÑÏ†ÅÏù∏ Î¨∏Ï†úÎ•º Îã®Í≥ÑÏ†ÅÏúºÎ°ú Ìï¥Í≤∞Ìï©ÎãàÎã§:

1. **Ï¶âÏãú ÏïàÏ†ïÌôî** (Phase 0)Î°ú ÌîÑÎ°úÎçïÏÖò Ïù¥Ïäà Ìï¥Í≤∞
2. **ÏïÑÌÇ§ÌÖçÏ≤ò Í∞úÏÑ†** (Phase 1-3)ÏúºÎ°ú Íµ¨Ï°∞Ï†Å Î¨∏Ï†ú Ìï¥Í≤∞
3. **ÏïàÏ†ÑÌïú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò** (Phase 4)ÏúºÎ°ú Í∏∞Ï°¥ Í∏∞Îä• Î≥¥Ìò∏
4. **ÏßÄÏÜçÏ†Å Í∞úÏÑ†** (Phase 5)ÏúºÎ°ú Ïû•Í∏∞Ï†Å ÏïàÏ†ïÏÑ± ÌôïÎ≥¥

Í∞Å Îã®Í≥ÑÎäî ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Î∞∞Ìè¨ Í∞ÄÎä•ÌïòÎ©∞, ÎπÑÏ¶àÎãàÏä§ ÏòÅÌñ•ÏùÑ ÏµúÏÜåÌôîÌïòÎ©¥ÏÑú Ï†êÏßÑÏ†ÅÏúºÎ°ú ÏãúÏä§ÌÖúÏùÑ Í∞úÏÑ†Ìï©ÎãàÎã§.

**ÏòàÏÉÅ Í≤∞Í≥º**:

- Ïù∏Ï¶ù Í¥ÄÎ†® Î≤ÑÍ∑∏ 70% Í∞êÏÜå
- Í∞úÎ∞ú ÏÉùÏÇ∞ÏÑ± 30% Ìñ•ÏÉÅ
- ÏÇ¨Ïö©Ïûê Í≤ΩÌóò ÎåÄÌè≠ Í∞úÏÑ†

Ïù¥ Í≥ÑÌöçÏùÑ ÌÜµÌï¥ ÏïàÏ†ïÏ†ÅÏù¥Í≥† ÌôïÏû• Í∞ÄÎä•Ìïú Ïù∏Ï¶ù ÏãúÏä§ÌÖúÏùÑ Íµ¨Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§.
