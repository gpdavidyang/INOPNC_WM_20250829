# 작업일지 페이지 개선안

## 📋 개요

현장관리자용 작업일지 페이지의 HTML 참조 구현과 현재 React 구현 간의 차이점을 분석하고, 개선 방향을 제시하는 문서입니다.

### 분석 기준
- **HTML 참조**: `/dy_memo/new_image_html_v2.0/DY_UI_Riquirements/작업일지.html` (1,265라인)
- **현재 구현**: `/modules/mobile/components/work-log/WorkLogCard.tsx` (281라인)
- **가이드 문서**: `/docs/DY0917_HTML2React_Guide.md` (576라인)
- **디자인 시스템**: `/dy_memo/new_image_html_v2.0/DY_UI_Riquirements/디자인CSS규칙.txt` (194라인)

---

## 🔍 주요 차이점 분석

### 1. 탭 시스템 구조

#### HTML 참조 (목표)
```html
<div class="tabs" role="tablist">
  <div class="tab active" data-tab="draft">임시저장</div>
  <div class="tab" data-tab="approved">작성완료</div>
</div>
<div class="tab-panels">
  <div class="panel active" data-panel="draft">
    <!-- 임시저장 작업일지 목록 -->
  </div>
  <div class="panel" data-panel="approved">
    <!-- 작성완료 작업일지 목록 -->
  </div>
</div>
```

#### 현재 구현 (React)
```tsx
// WorkLogHomePage.tsx:45-64
<div className="flex bg-white rounded-lg overflow-hidden shadow-sm">
  <button
    className={`flex-1 py-3 px-4 text-sm font-medium ${
      activeTab === 'draft' ? 'bg-[var(--brand)] text-white' : 'text-gray-600'
    }`}
    onClick={() => setActiveTab('draft')}
  >
    임시저장 ({draftCount})
  </button>
  <button
    className={`flex-1 py-3 px-4 text-sm font-medium ${
      activeTab === 'approved' ? 'bg-[var(--brand)] text-white' : 'text-gray-600'
    }`}
    onClick={() => setActiveTab('approved')}
  >
    작성완료 ({approvedCount})
  </button>
</div>
```

**차이점**:
- 현재 구현은 버튼 기반, HTML 참조는 의미론적 탭 구조
- 접근성(ARIA) 속성 누락
- 디자인 시스템 변수 활용 불완전

### 2. 검색 기능

#### HTML 참조 (목표)
```html
<div class="search" style="margin-bottom: 16px;">
  <input type="text" class="input" placeholder="작업일지 검색...">
  <div class="panel">
    <ul class="list">
      <li class="item"><mark>검색어</mark> 하이라이트</li>
    </ul>
  </div>
</div>
```

#### 현재 구현 (React)
```tsx
// WorkLogHomePage.tsx:66-74
<div className="relative mb-4">
  <input
    type="text"
    placeholder="작업일지 검색..."
    value={searchTerm}
    onChange={(e) => setSearchTerm(e.target.value)}
    className="w-full px-4 py-3 border border-gray-200 rounded-lg"
  />
</div>
```

**차이점**:
- 검색 결과 패널 및 하이라이트 기능 누락
- 자동완성 및 실시간 검색 결과 부재
- 검색어 하이라이트 기능 미구현

### 3. NPC 재료 관리 시스템

#### HTML 참조 (목표)
```html
<div class="npc-section">
  <h3>NPC-1000 사용량</h3>
  <div class="npc-input-group">
    <input type="number" class="input" placeholder="사용량">
    <select class="input">
      <option>kg</option>
      <option>L</option>
      <option>개</option>
    </select>
  </div>
  <div class="npc-history">
    <!-- 사용 이력 표시 -->
  </div>
</div>
```

#### 현재 구현 (React)
```tsx
// WorkLogModal.tsx:147-157에서 부분적으로 구현
{workLog.npcUsage && (
  <div className="mb-3 p-2 bg-yellow-50 rounded-lg">
    <div className="flex justify-between items-center">
      <span className="text-xs text-yellow-700">NPC-1000</span>
      <span className="text-xs font-semibold text-yellow-900">
        {workLog.npcUsage.amount}
        {workLog.npcUsage.unit}
      </span>
    </div>
  </div>
)}
```

**차이점**:
- 현재는 표시만 가능, 입력/편집 기능 부족
- 단위 선택 기능 미구현
- 사용 이력 추적 시스템 부재

### 4. 모달 시스템

#### HTML 참조 (목표)
```html
<div class="modal" id="workLogModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>작업일지 작성</h2>
      <button class="modal-close">&times;</button>
    </div>
    <div class="modal-body">
      <!-- 폼 컨텐츠 -->
    </div>
    <div class="modal-footer">
      <button class="btn btn--outline">취소</button>
      <button class="btn btn--primary">저장</button>
    </div>
  </div>
</div>
```

#### 현재 구현 (React)
```tsx
// WorkLogModal.tsx에서 Radix UI 기반 구현
<Dialog open={isOpen} onOpenChange={onClose}>
  <DialogContent className="max-w-lg mx-auto bg-white rounded-2xl p-6">
    {/* 모달 내용 */}
  </DialogContent>
</Dialog>
```

**차이점**:
- Radix UI 기반으로 접근성은 좋으나 디자인 통일성 부족
- HTML 참조의 명확한 헤더/바디/푸터 구조 부재

---

## 🎯 개선 목표

### 1. 접근성 향상
- 의미론적 HTML 구조 적용
- ARIA 속성 완전 구현
- 키보드 네비게이션 지원

### 2. 기능 완성도
- 검색 기능 고도화 (자동완성, 하이라이트)
- NPC 재료 관리 시스템 완전 구현
- 실시간 업데이트 및 상태 동기화

### 3. 디자인 시스템 통합
- CSS 변수 기반 테마 시스템 완전 적용
- 일관된 컴포넌트 디자인 언어
- 반응형 디자인 최적화

---

## 🚀 4단계 구현 계획

### Phase 1: 핵심 UI 구조 개선 (1-2주)

#### 1.1 탭 시스템 리팩토링
```tsx
// 새로운 TabSystem 컴포넌트
export const TabSystem = ({ 
  tabs, 
  activeTab, 
  onTabChange, 
  children 
}: TabSystemProps) => {
  return (
    <div className="tab-container">
      <div className="tabs" role="tablist">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            role="tab"
            aria-selected={activeTab === tab.id}
            aria-controls={`panel-${tab.id}`}
            className={cn(
              "tab",
              activeTab === tab.id && "active"
            )}
            onClick={() => onTabChange(tab.id)}
          >
            {tab.label}
            {tab.count && (
              <span className="tab-count">({tab.count})</span>
            )}
          </button>
        ))}
      </div>
      <div className="tab-panels">
        {children}
      </div>
    </div>
  )
}
```

#### 1.2 검색 시스템 고도화
```tsx
// 새로운 SearchWithSuggestions 컴포넌트
export const SearchWithSuggestions = ({
  value,
  onChange,
  onSearch,
  placeholder,
  suggestions = []
}: SearchProps) => {
  const [isOpen, setIsOpen] = useState(false)
  const [highlightedIndex, setHighlightedIndex] = useState(-1)

  return (
    <div className="search" ref={searchRef}>
      <input
        type="text"
        className="input"
        placeholder={placeholder}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onFocus={() => setIsOpen(true)}
        onKeyDown={handleKeyDown}
      />
      {isOpen && suggestions.length > 0 && (
        <div className="panel show">
          <ul className="list" role="listbox">
            {suggestions.map((suggestion, index) => (
              <li
                key={suggestion.id}
                className={cn(
                  "item",
                  index === highlightedIndex && "is-active"
                )}
                onClick={() => handleSelectSuggestion(suggestion)}
                dangerouslySetInnerHTML={{
                  __html: highlightSearchTerm(suggestion.text, value)
                }}
              />
            ))}
          </ul>
        </div>
      )}
    </div>
  )
}
```

### Phase 2: NPC 재료 관리 시스템 구현 (2-3주)

#### 2.1 NPC 입력 컴포넌트
```tsx
export const NPCMaterialInput = ({
  value,
  onChange,
  history = []
}: NPCMaterialInputProps) => {
  const [amount, setAmount] = useState(value?.amount || '')
  const [unit, setUnit] = useState(value?.unit || 'kg')

  return (
    <div className="npc-section">
      <div className="npc-header">
        <h3 className="t-h2">NPC-1000 사용량</h3>
        <button 
          className="btn btn--ghost"
          onClick={() => setShowHistory(!showHistory)}
        >
          사용 이력
        </button>
      </div>
      
      <div className="npc-input-group">
        <input
          type="number"
          className="input"
          placeholder="사용량"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
        <select
          className="input"
          value={unit}
          onChange={(e) => setUnit(e.target.value)}
        >
          <option value="kg">kg</option>
          <option value="L">L</option>
          <option value="개">개</option>
          <option value="m">m</option>
        </select>
      </div>

      {showHistory && (
        <div className="npc-history">
          <h4 className="t-cap">최근 사용 이력</h4>
          {history.map((record) => (
            <div key={record.id} className="npc-history-item">
              <span>{record.date}</span>
              <span>{record.amount}{record.unit}</span>
              <span>{record.site}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

#### 2.2 재료 사용량 추적 시스템
```tsx
// 새로운 훅: useMaterialTracking
export const useMaterialTracking = (siteId: string) => {
  const [usage, setUsage] = useState<MaterialUsage[]>([])
  const [loading, setLoading] = useState(false)

  const addUsage = useCallback(async (newUsage: MaterialUsageInput) => {
    setLoading(true)
    try {
      const result = await materialService.addUsage({
        ...newUsage,
        siteId,
        date: new Date().toISOString(),
        userId: getCurrentUser().id
      })
      setUsage(prev => [result, ...prev])
      return result
    } catch (error) {
      console.error('Failed to add material usage:', error)
      throw error
    } finally {
      setLoading(false)
    }
  }, [siteId])

  return {
    usage,
    addUsage,
    loading,
    refetch: () => fetchUsage(siteId)
  }
}
```

### Phase 3: 고급 기능 및 최적화 (2주)

#### 3.1 실시간 검색 및 필터링
```tsx
// useWorkLogSearch 훅 개선
export const useWorkLogSearch = (initialFilters?: WorkLogFilters) => {
  const [searchTerm, setSearchTerm] = useState('')
  const [filters, setFilters] = useState(initialFilters || {})
  const [suggestions, setSuggestions] = useState<SearchSuggestion[]>([])

  // 디바운스된 검색
  const debouncedSearchTerm = useDebounce(searchTerm, 300)

  // 검색 결과 쿼리
  const { data: searchResults, isLoading } = useQuery({
    queryKey: ['workLogs', 'search', debouncedSearchTerm, filters],
    queryFn: () => workLogService.search(debouncedSearchTerm, filters),
    enabled: debouncedSearchTerm.length > 0
  })

  // 자동완성 제안
  useEffect(() => {
    if (debouncedSearchTerm.length > 1) {
      workLogService.getSuggestions(debouncedSearchTerm)
        .then(setSuggestions)
    } else {
      setSuggestions([])
    }
  }, [debouncedSearchTerm])

  return {
    searchTerm,
    setSearchTerm,
    filters,
    setFilters,
    suggestions,
    searchResults,
    isLoading
  }
}
```

#### 3.2 상태 관리 최적화
```tsx
// WorkLog 상태 관리 개선
export const useWorkLogState = () => {
  const queryClient = useQueryClient()

  // 낙관적 업데이트
  const updateWorkLogMutation = useMutation({
    mutationFn: workLogService.update,
    onMutate: async (updatedWorkLog) => {
      await queryClient.cancelQueries({ queryKey: ['workLogs'] })
      
      const previousWorkLogs = queryClient.getQueryData(['workLogs'])
      
      queryClient.setQueryData(['workLogs'], (old: WorkLog[]) =>
        old?.map(workLog =>
          workLog.id === updatedWorkLog.id
            ? { ...workLog, ...updatedWorkLog }
            : workLog
        )
      )

      return { previousWorkLogs }
    },
    onError: (err, newWorkLog, context) => {
      queryClient.setQueryData(['workLogs'], context?.previousWorkLogs)
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['workLogs'] })
    }
  })

  return {
    updateWorkLog: updateWorkLogMutation.mutate,
    isUpdating: updateWorkLogMutation.isPending
  }
}
```

### Phase 4: 성능 최적화 및 접근성 완성 (1주)

#### 4.1 메모이제이션 최적화
```tsx
// WorkLogCard 성능 최적화
export const WorkLogCard = React.memo(({ 
  workLog, 
  onEdit, 
  onSubmit, 
  onView, 
  onPrint 
}: WorkLogCardProps) => {
  // 메모이제이션된 계산값
  const hasAttachments = useMemo(
    () => workLog.attachments.photos.length > 0 || 
          workLog.attachments.drawings.length > 0 || 
          workLog.attachments.confirmations.length > 0,
    [workLog.attachments]
  )

  const statusInfo = useMemo(
    () => getStatusInfo(workLog.status),
    [workLog.status]
  )

  // 안정적인 이벤트 핸들러
  const handleEdit = useCallback(() => onEdit?.(workLog.id), [onEdit, workLog.id])
  const handleSubmit = useCallback(() => onSubmit?.(workLog.id), [onSubmit, workLog.id])

  return (
    <article 
      className="work-log-card"
      aria-label={`작업일지: ${workLog.siteName}, ${formatDate(workLog.date)}`}
    >
      {/* 카드 내용 */}
    </article>
  )
}, (prevProps, nextProps) => {
  // 커스텀 비교 함수로 불필요한 리렌더링 방지
  return (
    prevProps.workLog.id === nextProps.workLog.id &&
    prevProps.workLog.status === nextProps.workLog.status &&
    prevProps.workLog.updatedAt === nextProps.workLog.updatedAt
  )
})
```

#### 4.2 접근성 개선
```tsx
// 키보드 네비게이션 및 스크린 리더 지원
export const AccessibleWorkLogList = ({ workLogs }: WorkLogListProps) => {
  const [focusedIndex, setFocusedIndex] = useState(0)
  const listRef = useRef<HTMLDivElement>(null)

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault()
        setFocusedIndex(prev => 
          Math.min(prev + 1, workLogs.length - 1)
        )
        break
      case 'ArrowUp':
        e.preventDefault()
        setFocusedIndex(prev => Math.max(prev - 1, 0))
        break
      case 'Enter':
      case ' ':
        e.preventDefault()
        // 포커스된 항목 활성화
        break
    }
  }, [workLogs.length])

  return (
    <div
      ref={listRef}
      role="region"
      aria-label="작업일지 목록"
      aria-live="polite"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      className="work-log-list"
    >
      {workLogs.map((workLog, index) => (
        <WorkLogCard
          key={workLog.id}
          workLog={workLog}
          aria-current={index === focusedIndex ? 'true' : undefined}
          tabIndex={index === focusedIndex ? 0 : -1}
        />
      ))}
    </div>
  )
}
```

---

## 📊 성과 지표

### 기술적 지표
- **접근성 점수**: WCAG 2.1 AA 준수 (목표: 95점 이상)
- **성능 점수**: Core Web Vitals 개선
  - LCP < 2.5초
  - FID < 100ms
  - CLS < 0.1
- **코드 품질**: ESLint/TypeScript 오류 0개 유지

### 사용자 경험 지표
- **검색 응답 시간**: 300ms 이하
- **모달 로딩 시간**: 200ms 이하
- **탭 전환 애니메이션**: 150ms 부드러운 전환

### 기능 완성도
- ✅ 의미론적 탭 시스템
- ✅ 고급 검색 및 자동완성
- ✅ NPC 재료 관리 시스템
- ✅ 실시간 상태 동기화
- ✅ 완전한 키보드 접근성

---

## 🔧 기술 스택 및 도구

### 핵심 기술
- **React 18**: Concurrent Features 활용
- **TypeScript 5+**: 엄격한 타입 검사
- **Next.js 14**: App Router 및 Server Components
- **React Query v5**: 서버 상태 관리
- **Radix UI**: 접근성 기반 컴포넌트

### 개발 도구
- **CVA (Class Variance Authority)**: 조건부 스타일링
- **Zod**: 런타임 타입 검증
- **React Hook Form**: 폼 상태 관리
- **Framer Motion**: 애니메이션 (필요시)

### 테스팅
- **Vitest**: 단위 테스트
- **Testing Library**: 컴포넌트 테스트
- **Playwright**: E2E 테스트
- **Axe**: 접근성 테스트

---

## 📝 결론

현재의 React 구현은 기본적인 기능은 제공하지만, HTML 참조 구현의 완성도와 사용자 경험에는 미치지 못합니다. 제안된 4단계 개선 계획을 통해 다음을 달성할 수 있습니다:

1. **완전한 기능 구현**: 검색, NPC 관리, 고급 필터링
2. **향상된 접근성**: WCAG 2.1 AA 준수
3. **최적화된 성능**: React 18의 최신 기능 활용
4. **일관된 디자인**: 디자인 시스템 완전 적용

이 개선안을 단계별로 구현하면 현장관리자들이 더욱 효율적으로 작업일지를 관리할 수 있는 완성도 높은 시스템을 제공할 수 있습니다.

---

**작성일**: 2025-09-18  
**작성자**: Claude  
**문서 버전**: v1.0